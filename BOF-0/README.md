> Source File: `vuln.c`
> Executable File: `vuln`
---
```
# ls
README.md  vuln  vuln.c
```
Detect `file type` first.
```
# file vuln
vuln: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=b53f59f147e1b0b087a736016a44d1db6dee530c, for GNU/Linux 3.2.0, not stripped
```
So, it's an ELF file. Lets make `executable` file and try to `run` it.
```
# chmod +x vuln
# ./vuln 
Please create 'flag.txt' in this directory with your own debugging flag.
```
So, we need to create `flag.txt` with dummmy content. Also, lets take a look on Source code.
```
# echo -n flag{WinayGupta777} | cat > flag.txt
# cat vuln.c
```
From the source code we can see, the global variable `flag` is set to the content of `flag.txt` file in `main()` function. And this `flag` is printed in `sigsegv_handler()` function. 

Line `signal(SIGSEGV, sigsegv_handler); // Set up signal handler` will listen for any `SIGSEGV` signal to this process when executable is running. 

So, We can get the `flag` printed in console if we can generate/send `SIGSEGV` signal to this executable while it's running.

#### How to generate/send `SIGSEGV` signal in/to process?

##### Method 1:
In linux, using `kill` command we can send any `signal` to process using `signal code`.

Experiment - 
Execute `vuln` binary.
```
# ./vuln 
Input: 
```
Let's check for the `PID` of this process and send `SIGSEGV` signal code => `11` to it.
```
(in other terminal:)
# ps -aux | grep vuln
root       28247  0.0  0.0   2764  1280 pts/0    S+   12:28   0:00 ./vuln
# kill -11 28247
```
So, as soon as we enter the command, other side will see the `flag` printed in the screen.
```
# ./vuln 
Input: flag{WinayGupta777}
```
